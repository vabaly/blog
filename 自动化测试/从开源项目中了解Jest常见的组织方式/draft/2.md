# 从开源项目中了解 Jest 常见的组织方式

## Vuetify

### 测试入口

Vuetify 把测试时机放在了 Git 提交前的钩子上，从 `package.json` 上可以看到：

```json
{
    // ...
    "husky": {
        "hooks": {
            "pre-commit": "node scripts/warn-npm-install.js && yarn run lint && yarn lerna run test -- -- -o"
        }
    }
    // ...
}
```

其中，`yarn lerna run test -- -- -o` 就是执行测试的脚本。一下就懵逼了。

在此之前，我从未看到过这种写法，大多数时候都是 `yarn run <npm-script>` 来执行 NPM 脚本对应的命令，所以很疑惑，就去 Yarn 官网上看了看。原来 `yarn` 是支持 `yarn <command> [--args]` 的写法的，而这里的 `<command>` 则是项目本地的命令行工具（即 node_modules/.bin/ 下的脚本）支持的命令。

到这里，我们就知道了 `lerna run test` 就是 `command`，可是后面两个 `--` 是什么意思呢？当我们实际运行 `yarn lerna run test -- -- -o` 的时候，会看到如下一个提示：

```
warning From Yarn 1.0 onwards, scripts don't require "--" for options to be forwarded. In a future version, any explicit "--" will be forwarded as-is to the scripts.
```

说明有一个 `--` 是 `yarn` 的老语法，这里提示说新版本不用传 `--` 了（但后面我们会知道不传的话就会运行错误了）。

同时，还会看到实际执行的命令是：

```sh
/<root-path>/vuetify/node_modules/.bin/lerna run test -- -o
```

那么 `lerna run test -- -o` 的作用是什么呢？我又去看了看 Lerna 的文档，它会执行 `packages` 目录下所有包中含有 `test` 脚本的命令（不含有的包会自动跳过），而 `--` 符号可以将后面的参数传递给 `test` 脚本，和 `yarn` 的 `--` 语法一致。

之前，我们提到，`yarn` 的新版本可以取消掉 `--`，后面直接跟参数，那么这里能否取消掉呢？显然是不行的，如果只留一个 `--`，那么这个 `--` 会被 `yarn` 识别，`lerna run test` 后面就少了一个 `--`，导致运行报错，所以两个 `--` 都得保留。

紧接着凭直觉，我会想为什么不直接用 `learn run test -- -o` 呢？以前直接写也会用本地的命令呀？结果灵光一闪，可能是平时写 npm scripts 写的太多了，才忽略了这只是 npm scripts 的特性，而这里是 husky 的配置，于是又去翻了翻 husky 的文档，发现里面提到如果要支持本地命令，还需要配置 `~/.huskyrc` 文件，证明了这一点。

所以说直觉真可怕，在 package.json 中写多了 scripts，在里面写其他脚本命令的时候很容易也陷入到陷阱中。

> 上述过程中，更加详细地看了下 Yarn、Npm、Husky 的特性，受益匪浅，有机会会专门总结一下。

### Packages 各包的 test 脚本

现在，我们就来找找 `packages` 下有哪些包拥有 `test` 脚本。很幸运，只有 `vuetify` 才有，脚本对应的命令如下：

```
"test": "node build/run-tests.js"
```

它实际执行 `run-tests.js`，我们再来看看 `build` 目录下的 `run-tests.js`，发现它针对不同系统运行了不同的测试脚本，Windows 下运行 `yarn test:win32 -o`，其他系统运行 `yarn test:unix -o`。

我们再来看看这两个脚本分别运行的什么，Windows 是 `jest -i -o`，其他系统是 `jest -o`（注意，当运行 `yarn <script> [...args]` 的时候，运行脚本对应的命令时也会加上 `args` 里的那些参数）。这有什么区别呢？我又打开了 `Jest` 文档来查看。`-i` 是 `--runInBand` 的短命名方式，`-i` 代表所有测试会串行地在当前进程中执行，这就能够逐步调试了，而 `Jest` 默认是将测试通过创建子进程地方式运行，无法调试，不过这里不知道为什么 Windows 要用这个选项。另外，`-o` 代表仅对更改地文件进行测试，配合 Git 使用这就很节约时间了。

### 测试开始

OK，现在终于运行 `Jest` 了，`Jest` 的运行还依赖于它的配置，我们来看一下 `jest.config.js` 文件，展开后的对象如下：

```js
{
  // ../../jest.config 展开后的配置
  verbose: false,
  testEnvironment: 'jest-environment-jsdom-fourteen',
  roots: [
    '<rootDir>/src',
  ],
  setupFilesAfterEnv: [
    '<rootDir>/test/index.ts',
  ],
  moduleFileExtensions: [
    'ts',
    'js',
  ],
  moduleDirectories: [
    'node_modules',
  ],
  moduleNameMapper: {
    '^@/test$': '<rootDir>/test/index.js',
    '^@/test/(.*)$': '<rootDir>/test/$1',
    '^@/(.*)$': '<rootDir>/src/$1',
    '\\.(css|sass|scss)$': 'identity-obj-proxy',
  },
  transform: {
    '\\.(styl)$': 'jest-css-modules',
    '\\.(sass|scss)$': 'jest-css-modules',
    '.*\\.(j|t)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.{js,ts,tsx}',
    '!**/*.d.ts',
  ],
  transformIgnorePatterns: [
    // 排除 vue-router 包以外的都被忽略
    // 说明 vue-router 这个还是要被 `ts-jest` 转译，这里还没看懂为什么
    'node_modules/(?!vue-router)',
  ],
  snapshotSerializers: [
    'jest-serializer-html',
  ],
  testMatch: [
    // Default
    '**/test/**/*.js',
    '**/__tests__/**/*.spec.js',
    '**/__tests__/**/*.spec.ts',
  ],
  // 全局对象配置，里面的属性会暴露在测试环境的全局变量中？
  globals: {
    'ts-jest': {
      babelConfig: true,
      tsConfig: '<rootDir>/tsconfig.test.json',
      diagnostics: false,
    },
  },

  // jest.config.js 特有的配置
  name: 'Vuetify',
  displayName: 'Vuetify',
  setupFiles: [
    'jest-canvas-mock'
  ]
}
```

下面进入每一项配置的详细解读：

* verbose：是否在运行期间展示每个单独的测试情况（PASS or Fail）。不过无论设置什么，都会在尾部显示测试错误信息以及总体通过情况，可看下面两张图体会：

  1. verbose 设为 false 的时候：
    ![verbose-false](./images/verbose-false.png)
  2. verbose 设为 true 的时候：
    ![verbose](./images/verbose.png)

  不过不知道官方文档为什么说 `verbose` 的默认值是 `false`，而根据我的实践，其实 `verbose` 的默认值是 `true`，什么都不配置就是会显示每个单独测试用例的测试情况，而且 `vuetify` 的配置中还特地设置了 `verbose` 为 `false`，如果默认值为 `false`，那为什么还要设置呢？

  上面的结论有问题，默认值确实是 `false`，但是当只有一个测试文件运行时，还是会显示出每个单独测试用例的测试情况，多个测试文件运行时，就不会显示出来了。只有 `verbose` 为 `true` 时才会显示出来。

* testEnvironment：测试用例运行的环境。
  * jsdom。默认值，一个类似于浏览器的环境。
  * node。一个类似于 Node 的环境。
  * `<package-name>`。使用 NPM 包中的某个环境。例如，第一个 `jsdom` 选项其实是 Jest 默认带的 `jsdom@11`，如果想用更高版本的 `jsdom`，就得自己安装了。`vuetify` 使用的就是自己安装的高版本 `jsdom` 环境，即 `jest-environment-jsdom-fourteen`。

  文档上还提到，如果要让某个文件下的测试用例走单独的环境，可以在文件顶部加 `@jest-environment <env>` 注释来实现。

  另外，Jest 还支持自定义测试环境，由于当前不需要做这些，我就先忽略了，**不过在这里 Mark 一下，方便后续来填坑。**

  这里为什么要用高版本 `jsdom` 呢？我猜越高的版本实现的浏览器的 API 越多，正好可能 `vuetify` 要用到或者将来要用到更高级的 API，所以就用了高版本的 `jsdom` 了。

* roots：这个配置就是定义 Jest 从哪些目录里面去搜索测试文件。默认值就是 `<rootDir>`，而 `<rootDir>` 的默认值是什么呢。这里我们可以顺便看一下 `<rootDir>` 的配置。

* rootDir：这个就是设置 `Jest` 配置中 `<rootDir>` 变量的值。默认就是 `Jest` 配置所在的目录，如果你的配置写在 `package.json` 文件中，那就是 `package.json` 文件所在的目录。

* setupFilesAfterEnv：貌似是在每个测试用例前执行的文件列表，用来设置测试框架。**后面详细研究一下，先 Mark 了。**

* moduleFileExtensions：测试代码文件中引用模块时会用到，例如你写了 `require('./a)`，然后 moduleFileExtensions 配的是 ['ts', 'js']，那就先找 `./a.ts`，找不到就找 `./a.js`，所以你的项目用什么语言写的，就应该把该语言的后缀名放在最前面，**但是必须包含 `js`**。

* moduleDirectories：定义测试代码文件中 `require(<module-name>)` 的模块搜索路径，它和 Node 一样都是递归搜索，默认会搜 `node_modules`，当然你也可以添加其他路径。这个好像一般都不需要改。

* moduleNameMapper：模块路径映射，键是正则表达式，值是模块地址，可以用 `$1` 之类的符号来表示匹配地址。必须是完整的模块路径，这点很重要，和 `Webpack` 中的 `alias` 有所不同，这个我也是试了很多次才发现的，比如以 `Webpack` 的思维，我想用 `@` 代替 `src/`，这里就不能写 `@: '<rootDir>/src'` 了，得写成 `'^@/(.*)$': '<rootDir>/src/$1'`，`$1` 解析出来后就是个完整的模块路径，这种思维转变很重要。

  * 另外，由于我是用 `Typescript` 写的项目，光配置 `moduleNameMapper` 好像还不生效，得配置以下内容才生效：

    ```json
    globals: {
      'ts-jest': {
        diagnostics: false,
      },
    },
    ```

    这个是为什么暂时还不清楚，**先 Mark 一下。**

* collectCoverageFrom：收集符合 Glob 模式匹配的文件的测试覆盖率，这个和 `collectCoverage` 属性是相关联的，只有 `collectCoverage` 设为 `true`，这个配置才有用，不知道这里为什么只用 `collectCoverageFrom`，在我的实践中是不生效的。

  `collectCoverageFrom` 和 `collectCoverage` 的区别是，如果设置了 `collectCoverage` 为 `true`，那么就只会收集测试用用到的测试文件的测试覆盖率，如果又设置了 `collectCoverageFrom`，则只会收集 `collectCoverageFrom` 指定的文件的测试覆盖率，而且不管该文件有没有在测试中被用到，都会收集，不过该文件的测试覆盖率自然就是零了。

* testMatch：这是一个很重要的属性，不知道为什么官网不最先说，我连 Jest 怎么搜索到测试文件来跑的都不知道，那我怎么知道该怎么写测试文件呢？

  **默认情况下，Jest 搜索测试文件的原则如下：**

    * 以 jest.config.js 配置文件或 package.json 所在位置（一般也是 Jest 命令运行的目录）为根目录；
    * 搜索根目录下所有 `__test__` 文件夹下的 `js`、`.jsx`、`ts`、`.tsx` 的文件，作为测试文件放到测试环境中运行；
    * 搜索根目录下所有后缀为 `.test.[js|ts|jsx|tsx]` 或 `.spec.[js|ts|jsx|tsx]` 的文件；
    * 搜索根目录下所有名为 `test.[js|ts|jsx|tsx]` 或 `spec.[js|ts|jsx|tsx]` 的文件。

  **自定义后，搜索的文件就从根目录按自定义的路径和文件类型来搜寻测试文件。**

* displayName：定义在每个测试文件信息旁边显示的名字，比如设置 `displayName: 'TEST'` 之后，就是下面这张图这样：

  ![显示文字](./images/display-name.png)

*


## 参考文档

* [NPM 中文文档](https://www.npmjs.cn/)
* [Yarn 中文文档](https://yarnpkg.com/zh-Hans/docs)
* []
